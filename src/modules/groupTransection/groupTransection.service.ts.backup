import mongoose from "mongoose";
import { GroupTransactionModel } from "./groupTransection.model";
import { UserModel } from "../user/user.model";

const createGroupTransaction = async ({ groupName, user_id }: { groupName: string, user_id: mongoose.Types.ObjectId | null }) => {
    try {

        const generatedGroupId = new mongoose.Types.ObjectId();

        const userEmail = await UserModel.findById(user_id).select('email').lean().then(user => user?.email || null);

        const newGroup = new GroupTransactionModel({
            groupId: ge    };
};

// Get comprehensive group status with summary and breakdowns
const getGroupStatus = async ({ 
    groupId, 
    user_id 
}: { 
    groupId: string, 
    user_id: mongoose.Types.ObjectId | null
}) => {
    try {
        // Get user email
        const userEmail = await UserModel.findById(user_id).select('email').lean().then(user => user?.email || null);
        
        if (!userEmail) {
            throw new Error('User email not found');
        }

        // Find the group with populated category data
        const group = await GroupTransactionModel.findOne({ groupId: parseInt(groupId) })
            .populate('groupExpenses.category', 'name')
            .lean();

        if (!group) {
            throw new Error('Group not found');
        }

        // Verify user is member or owner
        const isOwner = group.ownerEmail === userEmail;
        const isMember = group.groupMembers?.includes(userEmail);
        
        if (!isOwner && !isMember) {
            throw new Error('You are not authorized to view this group status');
        }

        // Get all group members including owner
        const allMembers = [group.ownerEmail, ...(group.groupMembers || [])];
        
        // Calculate balances for all members
        const balances = await calculateGroupBalances(groupId);
        
        // Initialize summary data
        let totalGroupExpenses = 0;
        let userTotalPaid = 0;
        let userTotalOwes = 0;
        
        // Category-wise breakdown
        const categoryBreakdown: { [categoryName: string]: {
            totalAmount: number,
            userPaid: number,
            userOwes: number,
            percentage: number,
            currency: string
        }} = {};
        
        // Person-wise breakdown
        const personBreakdown: { [email: string]: {
            totalInvolved: number,
            userPaidToThem: number,
            userOwesFromThem: number,
            percentage: number,
            currency: string
        }} = {};

        // Process each expense
        for (const expense of group.groupExpenses || []) {
            totalGroupExpenses += expense.totalExpenseAmount;
            
            const categoryName = (expense.category as any)?.name || 'Unknown';
            
            // Initialize category if not exists
            if (!categoryBreakdown[categoryName]) {
                categoryBreakdown[categoryName] = {
                    totalAmount: 0,
                    userPaid: 0,
                    userOwes: 0,
                    percentage: 0,
                    currency: expense.currency
                };
            }
            
            // Add to category total
            categoryBreakdown[categoryName].totalAmount += expense.totalExpenseAmount;
            
            // Calculate user's payment for this expense
            let userPaidInExpense = 0;
            if (expense.paidBy.type === 'individual' && expense.paidBy.memberEmail === userEmail) {
                userPaidInExpense = expense.paidBy.amount;
            } else if (expense.paidBy.type === 'multiple') {
                const userPayment = expense.paidBy.payments?.find(p => p.memberEmail === userEmail);
                userPaidInExpense = userPayment?.amount || 0;
            }
            
            userTotalPaid += userPaidInExpense;
            categoryBreakdown[categoryName].userPaid += userPaidInExpense;
            
            // Calculate user's share for this expense
            let userOwesInExpense = 0;
            if (expense.shareWith.type === 'equal' && expense.shareWith.members.includes(userEmail)) {
                userOwesInExpense = expense.totalExpenseAmount / expense.shareWith.members.length;
            } else if (expense.shareWith.type === 'custom') {
                const userShare = expense.shareWith.shares?.find(s => s.memberEmail === userEmail);
                userOwesInExpense = userShare?.amount || 0;
            }
            
            userTotalOwes += userOwesInExpense;
            categoryBreakdown[categoryName].userOwes += userOwesInExpense;
            
            // Process person-wise breakdown
            // For people who paid in this expense
            if (expense.paidBy.type === 'individual') {
                const payerEmail = expense.paidBy.memberEmail;
                if (!personBreakdown[payerEmail]) {
                    personBreakdown[payerEmail] = {
                        totalInvolved: 0,
                        userPaidToThem: 0,
                        userOwesFromThem: 0,
                        percentage: 0,
                        currency: expense.currency
                    };
                }
                personBreakdown[payerEmail].totalInvolved += expense.paidBy.amount;
                
                if (payerEmail !== userEmail) {
                    // If user owes share to this person
                    if (expense.shareWith.type === 'equal' && expense.shareWith.members.includes(userEmail)) {
                        personBreakdown[payerEmail].userOwesFromThem += userOwesInExpense;
                    } else if (expense.shareWith.type === 'custom') {
                        personBreakdown[payerEmail].userOwesFromThem += userOwesInExpense;
                    }
                }
            } else if (expense.paidBy.type === 'multiple') {
                for (const payment of expense.paidBy.payments || []) {
                    if (!personBreakdown[payment.memberEmail]) {
                        personBreakdown[payment.memberEmail] = {
                            totalInvolved: 0,
                            userPaidToThem: 0,
                            userOwesFromThem: 0,
                            percentage: 0,
                            currency: expense.currency
                        };
                    }
                    personBreakdown[payment.memberEmail].totalInvolved += payment.amount;
                    
                    if (payment.memberEmail === userEmail) {
                        personBreakdown[payment.memberEmail].userPaidToThem += payment.amount;
                    }
                }
            }
        }
        
        // Calculate percentages for categories
        for (const category in categoryBreakdown) {
            if (totalGroupExpenses > 0) {
                categoryBreakdown[category].percentage = (categoryBreakdown[category].totalAmount / totalGroupExpenses) * 100;
            }
        }
        
        // Calculate percentages for persons and clean up data
        for (const person in personBreakdown) {
            if (totalGroupExpenses > 0) {
                personBreakdown[person].percentage = (personBreakdown[person].totalInvolved / totalGroupExpenses) * 100;
            }
        }

        // Calculate user's involvement percentage
        const userInvolvementPercentage = totalGroupExpenses > 0 ? (userTotalOwes / totalGroupExpenses) * 100 : 0;
        
        // Get user's net balance
        const userBalance = balances[userEmail] || { paid: 0, owes: 0, net: 0 };
        
        // Determine involved currencies (get unique currencies from expenses)
        const involvedCurrencies = [...new Set((group.groupExpenses || []).map(exp => exp.currency))];
        
        return {
            group: {
                groupId: group.groupId,
                groupName: group.groupName,
                ownerEmail: group.ownerEmail,
                totalMembers: allMembers.length,
                totalExpenses: totalGroupExpenses
            },
            summary: {
                involvedCurrency: involvedCurrencies.length === 1 ? involvedCurrencies[0] : 'Mixed',
                involvedAmount: userTotalOwes,
                myExpensesPercentage: parseFloat(userInvolvementPercentage.toFixed(2)),
                myExpensesCurrency: involvedCurrencies.length === 1 ? involvedCurrencies[0] : 'Mixed',
                myExpensesAmount: userTotalPaid,
                netBalance: {
                    amount: Math.abs(userBalance.net),
                    status: userBalance.net > 0 ? 'you_are_owed' : userBalance.net < 0 ? 'you_owe' : 'settled',
                    currency: involvedCurrencies.length === 1 ? involvedCurrencies[0] : 'Mixed'
                }
            },
            categoryWise: Object.keys(categoryBreakdown).map(categoryName => ({
                categoryName,
                totalAmount: categoryBreakdown[categoryName].totalAmount,
                currency: categoryBreakdown[categoryName].currency,
                percentage: parseFloat(categoryBreakdown[categoryName].percentage.toFixed(2)),
                myInvolvement: {
                    paid: categoryBreakdown[categoryName].userPaid,
                    owes: categoryBreakdown[categoryName].userOwes,
                    percentage: categoryBreakdown[categoryName].totalAmount > 0 ? 
                        parseFloat(((categoryBreakdown[categoryName].userOwes / categoryBreakdown[categoryName].totalAmount) * 100).toFixed(2)) : 0
                }
            })).sort((a, b) => b.totalAmount - a.totalAmount),
            personWise: Object.keys(personBreakdown).map(email => ({
                memberEmail: email,
                totalInvolved: personBreakdown[email].totalInvolved,
                currency: personBreakdown[email].currency,
                percentage: parseFloat(personBreakdown[email].percentage.toFixed(2)),
                myRelation: {
                    paidToThem: personBreakdown[email].userPaidToThem,
                    owesFromThem: personBreakdown[email].userOwesFromThem,
                    net: personBreakdown[email].userPaidToThem - personBreakdown[email].userOwesFromThem,
                    status: email === userEmail ? 'myself' : 
                            (personBreakdown[email].userPaidToThem - personBreakdown[email].userOwesFromThem) > 0 ? 'they_owe_me' :
                            (personBreakdown[email].userPaidToThem - personBreakdown[email].userOwesFromThem) < 0 ? 'i_owe_them' : 'settled'
                }
            })).sort((a, b) => b.totalInvolved - a.totalInvolved),
            currencies: involvedCurrencies,
            lastUpdated: new Date().toISOString()
        };

    } catch (error: any) {
        console.error('Error in getGroupStatus service:', error.message);
        throw new Error(`Failed to get group status: ${error.message}`);
    }
};

const createGroupTransaction = async ({ groupName, user_id }: { groupName: string, user_id: mongoose.Types.ObjectId | null }) => {
    try {
        if (!user_id) {
            throw new Error('User ID is required');
        }

        // Get user email for the new group
        const userEmail = await UserModel.findById(user_id).select('email').lean().then(user => user?.email || null);
        
        if (!userEmail) {
            throw new Error('User email not found');
        }

        const generatedGroupId = Math.floor(Date.now() / 1000);
        const newGroup = new GroupTransactionModel({
            groupId: generatedGroupId,
            groupName,
            ownerId: user_id,
            ownerEmail: userEmail,
        });
        await newGroup.save();
        return newGroup;
    } catch (error: any) {
        console.error('Error in createGroupTransaction service:', error.message);
        throw new Error(`Failed to create group transaction: ${error.message}`);
    }
};

const addGroupMember = async ({ groupId, members, user_id }: { groupId: string, members: string[], user_id: mongoose.Types.ObjectId | null }) => {
    try {

        const group = await GroupTransactionModel.findOne({ groupId: parseInt(groupId) });

        if (!group) {
            throw new Error('Group not found');
        }

        // Add new members to the groupMembers array, avoiding duplicates
        group.groupMembers = Array.from(new Set([...(group.groupMembers ?? []), ...members]));

        await group.save();
        return group;

    } catch (error: any) {
        console.error('Error in addGroupMember service:', error.message);
        throw new Error(`Failed to add group member: ${error.message}`);
    }
};


const addGroupExpense = async ({ groupId, expenseData, user_id }: { groupId: string, expenseData: any, user_id: mongoose.Types.ObjectId | null }) => {
    const session = await mongoose.startSession();
    session.startTransaction();

    try {
        // Find the group
        const group = await GroupTransactionModel.findOne({ groupId: parseInt(groupId) }).session(session);

        if (!group) {
            throw new Error('Group not found');
        }

        const userEmail = await UserModel.findById(user_id).select('email').lean().then(user => user?.email || null);

        if (!userEmail) {
            throw new Error('User email not found');
        }

        // Verify user is group owner or member
        const isOwner = group.ownerId?.toString() === user_id?.toString();
        const isMember = group.groupMembers?.includes(userEmail?.toString() || '');

        if (!isOwner && !isMember) {
            throw new Error('You are not authorized to add expenses to this group');
        }

        // Validate required expense data
        const {
            expenseDate,
            totalExpenseAmount,
            currency,
            category,
            note,
            paidBy,
            shareWith
        } = expenseData;

        // Basic validation
        if (!expenseDate || !totalExpenseAmount || !currency || !category || !paidBy || !shareWith) {
            throw new Error('Missing required expense fields: expenseDate, totalExpenseAmount, currency, category, paidBy, shareWith');
        }

        if (totalExpenseAmount <= 0) {
            throw new Error('Total expense amount must be greater than 0');
        }

        // Validate paidBy structure
        await validatePaidBy(paidBy, totalExpenseAmount, group);

        // Validate shareWith structure
        await validateShareWith(shareWith, totalExpenseAmount, group);

        // Create expense object
        const newExpense = {
            expenseDate: new Date(expenseDate),
            totalExpenseAmount,
            currency,
            category: new mongoose.Types.ObjectId(category),
            note: note || '',
            paidBy,
            shareWith
        };

        // Add expense to group
        if (!group.groupExpenses) {
            group.groupExpenses = [];
        }

        group.groupExpenses.push(newExpense as any);

        // Save the updated group
        const updatedGroup = await group.save({ session });

        await session.commitTransaction();
        return updatedGroup;

    } catch (error: any) {
        await session.abortTransaction();
        console.error('Error in addGroupExpense service:', error.message);
        throw new Error(`Failed to add group expense: ${error.message}`);
    } finally {
        session.endSession();
    }
};

// Helper function to validate paidBy structure
const validatePaidBy = async (paidBy: any, totalAmount: number, group: any) => {
    if (!paidBy.type || !['individual', 'multiple'].includes(paidBy.type)) {
        throw new Error('paidBy.type must be either "individual" or "multiple"');
    }

    if (paidBy.type === 'individual') {
        if (!paidBy.memberEmail || !paidBy.amount) {
            throw new Error('For individual payment, memberEmail and amount are required');
        }

        if (paidBy.amount !== totalAmount) {
            throw new Error('For individual payment, amount must equal totalExpenseAmount');
        }

        // Verify member exists in group
        const memberExists = group.ownerEmail === paidBy.memberEmail ||
            group.groupMembers?.includes(paidBy.memberEmail);

        if (!memberExists) {
            throw new Error('Paying member is not part of this group');
        }

    } else if (paidBy.type === 'multiple') {
        if (!paidBy.payments || !Array.isArray(paidBy.payments) || paidBy.payments.length === 0) {
            throw new Error('For multiple payments, payments array is required');
        }

        let totalPaid = 0;
        const memberEmails = new Set();

        for (const payment of paidBy.payments) {
            if (!payment.memberEmail || !payment.amount) {
                throw new Error('Each payment must have memberEmail and amount');
            }

            if (payment.amount <= 0) {
                throw new Error('Payment amount must be greater than 0');
            }

            // Check for duplicate members
            if (memberEmails.has(payment.memberEmail)) {
                throw new Error('Duplicate member in payments array');
            }
            memberEmails.add(payment.memberEmail);

            // Verify member exists in group
            const memberExists = group.ownerEmail === payment.memberEmail ||
                group.groupMembers?.includes(payment.memberEmail);

            if (!memberExists) {
                throw new Error(`Paying member ${payment.memberEmail} is not part of this group`);
            }

            totalPaid += payment.amount;
        }

        // Allow small floating-point differences
        if (Math.abs(totalPaid - totalAmount) > 0.01) {
            throw new Error(`Total payments (${totalPaid}) must equal totalExpenseAmount (${totalAmount})`);
        }
    }
};

// Helper function to validate shareWith structure
const validateShareWith = async (shareWith: any, totalAmount: number, group: any) => {
    if (!shareWith.type || !['equal', 'custom'].includes(shareWith.type)) {
        throw new Error('shareWith.type must be either "equal" or "custom"');
    }

    if (shareWith.type === 'equal') {
        if (!shareWith.members || !Array.isArray(shareWith.members) || shareWith.members.length === 0) {
            throw new Error('For equal sharing, members array is required');
        }

        // Verify all members exist in group
        for (const memberEmail of shareWith.members) {
            const memberExists = group.ownerEmail === memberEmail ||
                group.groupMembers?.includes(memberEmail);

            if (!memberExists) {
                throw new Error(`Sharing member ${memberEmail} is not part of this group`);
            }
        }

        // Check for duplicate members
        const uniqueMembers = new Set(shareWith.members);
        if (uniqueMembers.size !== shareWith.members.length) {
            throw new Error('Duplicate members in sharing list');
        }

    } else if (shareWith.type === 'custom') {
        if (!shareWith.shares || !Array.isArray(shareWith.shares) || shareWith.shares.length === 0) {
            throw new Error('For custom sharing, shares array is required');
        }

        let totalShares = 0;
        const memberEmails = new Set();

        for (const share of shareWith.shares) {
            if (!share.memberEmail || !share.amount) {
                throw new Error('Each share must have memberEmail and amount');
            }

            if (share.amount <= 0) {
                throw new Error('Share amount must be greater than 0');
            }

            // Check for duplicate members
            if (memberEmails.has(share.memberEmail)) {
                throw new Error('Duplicate member in shares array');
            }
            memberEmails.add(share.memberEmail);

            // Verify member exists in group
            const memberExists = group.ownerEmail === share.memberEmail ||
                group.groupMembers?.includes(share.memberEmail);

            if (!memberExists) {
                throw new Error(`Sharing member ${share.memberEmail} is not part of this group`);
            }

            totalShares += share.amount;
        }

        // Allow small floating-point differences
        if (Math.abs(totalShares - totalAmount) > 0.01) {
            throw new Error(`Total shares (${totalShares}) must equal totalExpenseAmount (${totalAmount})`);
        }
    }
};

// Calculate group balances and debts
const calculateGroupBalances = async (groupId: string) => {
    try {
        const group = await GroupTransactionModel.findOne({ groupId: parseInt(groupId) });

        if (!group || !group.groupExpenses) {
            throw new Error('Group not found or no expenses');
        }

        // Create member balance map
        const memberBalances: { [key: string]: { paid: number, owes: number, net: number } } = {};

        // Initialize all members
        const allMembers = [
            ...(group.ownerEmail ? [group.ownerEmail] : []),
            ...(group.groupMembers || [])
        ];

        allMembers.forEach(memberEmail => {
            memberBalances[memberEmail] = { paid: 0, owes: 0, net: 0 };
        });

        // Process each expense
        for (const expense of group.groupExpenses) {
            // Calculate who paid what
            if (expense.paidBy.type === 'individual') {
                const payerEmail = expense.paidBy.memberEmail;
                memberBalances[payerEmail].paid += expense.paidBy.amount;
            } else {
                expense.paidBy.payments?.forEach(payment => {
                    const payerEmail = payment.memberEmail;
                    memberBalances[payerEmail].paid += payment.amount;
                });
            }

            // Calculate who owes what
            if (expense.shareWith.type === 'equal') {
                const shareAmount = expense.totalExpenseAmount / expense.shareWith.members.length;
                expense.shareWith.members.forEach(memberEmail => {
                    memberBalances[memberEmail].owes += shareAmount;
                });
            } else {
                expense.shareWith.shares?.forEach(share => {
                    const memberEmail = share.memberEmail;
                    memberBalances[memberEmail].owes += share.amount;
                });
            }
        }

        // Calculate net balances
        Object.keys(memberBalances).forEach(memberEmail => {
            memberBalances[memberEmail].net = memberBalances[memberEmail].paid - memberBalances[memberEmail].owes;
        }); return memberBalances;
    } catch (error: any) {
        console.error('Error in calculateGroupBalances:', error.message);
        throw new Error(`Failed to calculate group balances: ${error.message}`);
    }
};

// Get group summary with balances
const getGroupSummary = async (groupId: string) => {
    try {
        const group = await GroupTransactionModel.findOne({ groupId: parseInt(groupId) })
            .populate('groupExpenses.category')
            .populate('ownerId', 'name email');

        if (!group) {
            throw new Error('Group not found');
        }

        const balances = await calculateGroupBalances(groupId);

        // Calculate total expenses
        const totalExpenses = group.groupExpenses?.reduce((sum, expense) => sum + expense.totalExpenseAmount, 0) || 0;

        // Get expense categories breakdown
        const categoryBreakdown: { [key: string]: number } = {};
        group.groupExpenses?.forEach(expense => {
            const categoryName = (expense.category as any)?.name || 'Unknown';
            categoryBreakdown[categoryName] = (categoryBreakdown[categoryName] || 0) + expense.totalExpenseAmount;
        });

        return {
            group: {
                groupId: group.groupId,
                groupName: group.groupName,
                ownerId: group.ownerId,
                memberCount: (group.groupMembers?.length || 0) + 1, // +1 for owner
                totalExpenses,
                expenseCount: group.groupExpenses?.length || 0
            },
            balances,
            categoryBreakdown,
            recentExpenses: group.groupExpenses?.slice(-5) || [] // Last 5 expenses
        };
    } catch (error: any) {
        console.error('Error in getGroupSummary:', error.message);
        throw new Error(`Failed to get group summary: ${error.message}`);
    }
};

// Settle debt between members (future feature)
const settleDebt = async (groupId: string, fromMemberId: string, toMemberId: string, amount: number) => {
    // This would be implemented for recording settlements
    // For now, return a placeholder
    return {
        message: 'Debt settlement feature coming soon',
        groupId,
        settlement: {
            from: fromMemberId,
            to: toMemberId,
            amount,
            date: new Date()
        }
    };
};

// Get comprehensive group transactions with filtering and user-specific data
const getGroupTransactions = async ({ 
    groupId, 
    user_id, 
    filters 
}: { 
    groupId: string, 
    user_id: mongoose.Types.ObjectId | null,
    filters?: {
        expenseView?: 'all' | 'involving_me_only',
        transactionType?: 'i_borrowed' | 'i_lent' | 'all',
        search?: string
    }
}) => {
    try {
        // Get user email
        const userEmail = await UserModel.findById(user_id).select('email').lean().then(user => user?.email || null);
        
        if (!userEmail) {
            throw new Error('User email not found');
        }

        // Find the group with populated category data
        const group = await GroupTransactionModel.findOne({ groupId: parseInt(groupId) })
            .populate('groupExpenses.category', 'name')
            .lean();

        if (!group) {
            throw new Error('Group not found');
        }

        // Verify user is member or owner
        const isOwner = group.ownerEmail === userEmail;
        const isMember = group.groupMembers?.includes(userEmail);
        
        if (!isOwner && !isMember) {
            throw new Error('You are not authorized to view this group');
        }

        // Calculate user-specific summary
        const balances = await calculateGroupBalances(groupId);
        const userBalance = balances[userEmail] || { paid: 0, owes: 0, net: 0 };
        
        const youllPay = userBalance.net < 0 ? Math.abs(userBalance.net) : 0;
        const youllCollect = userBalance.net > 0 ? userBalance.net : 0;

        // Process expenses with user-specific data
        let expenses = group.groupExpenses || [];

        // Apply search filter
        if (filters?.search) {
            const searchTerm = filters.search.toLowerCase();
            expenses = expenses.filter(expense => {
                const categoryName = (expense.category as any)?.name?.toLowerCase() || '';
                const note = expense.note?.toLowerCase() || '';
                return categoryName.includes(searchTerm) || note.includes(searchTerm);
            });
        }

        // Process each expense to add user-specific data
        const processedExpenses = expenses.map(expense => {
            // Calculate user's involvement in this expense
            let userPaid = 0;
            let userOwes = 0;

            // Check if user paid
            if (expense.paidBy.type === 'individual' && expense.paidBy.memberEmail === userEmail) {
                userPaid = expense.paidBy.amount;
            } else if (expense.paidBy.type === 'multiple') {
                const userPayment = expense.paidBy.payments?.find(p => p.memberEmail === userEmail);
                userPaid = userPayment?.amount || 0;
            }

            // Check how much user owes
            if (expense.shareWith.type === 'equal' && expense.shareWith.members.includes(userEmail)) {
                userOwes = expense.totalExpenseAmount / expense.shareWith.members.length;
            } else if (expense.shareWith.type === 'custom') {
                const userShare = expense.shareWith.shares?.find(s => s.memberEmail === userEmail);
                userOwes = userShare?.amount || 0;
            }

            const userNet = userPaid - userOwes;
            
            return {
                _id: (expense as any)._id,
                expenseDate: expense.expenseDate,
                totalExpenseAmount: expense.totalExpenseAmount,
                currency: expense.currency,
                category: expense.category,
                note: expense.note,
                paidBy: expense.paidBy,
                shareWith: expense.shareWith,
                userInvolvement: {
                    paid: userPaid,
                    owes: userOwes,
                    net: userNet,
                    status: userNet > 0 ? 'you_lent' : userNet < 0 ? 'you_borrowed' : 'settled',
                    amount: Math.abs(userNet)
                }
            };
        });

        // Apply expense view filter
        let filteredExpenses = processedExpenses;
        if (filters?.expenseView === 'involving_me_only') {
            filteredExpenses = processedExpenses.filter(expense => 
                expense.userInvolvement.paid > 0 || expense.userInvolvement.owes > 0
            );
        }

        // Apply transaction type filter
        if (filters?.transactionType && filters.transactionType !== 'all') {
            if (filters.transactionType === 'i_borrowed') {
                filteredExpenses = filteredExpenses.filter(expense => expense.userInvolvement.status === 'you_borrowed');
            } else if (filters.transactionType === 'i_lent') {
                filteredExpenses = filteredExpenses.filter(expense => expense.userInvolvement.status === 'you_lent');
            }
        }

        // Group expenses by category and date
        const expensesByCategory: { [key: string]: any[] } = {};
        const expensesByDate: { [key: string]: any[] } = {};

        filteredExpenses.forEach(expense => {
            const categoryName = (expense.category as any)?.name || 'Unknown';
            const dateKey = new Date(expense.expenseDate).toISOString().split('T')[0];

            if (!expensesByCategory[categoryName]) {
                expensesByCategory[categoryName] = [];
            }
            if (!expensesByDate[dateKey]) {
                expensesByDate[dateKey] = [];
            }

            expensesByCategory[categoryName].push(expense);
            expensesByDate[dateKey].push(expense);
        });

        // Calculate totals
        const totalExpenses = filteredExpenses.reduce((sum, exp) => sum + exp.totalExpenseAmount, 0);
        const totalUserBorrowed = filteredExpenses
            .filter(exp => exp.userInvolvement.status === 'you_borrowed')
            .reduce((sum, exp) => sum + exp.userInvolvement.amount, 0);
        const totalUserLent = filteredExpenses
            .filter(exp => exp.userInvolvement.status === 'you_lent')
            .reduce((sum, exp) => sum + exp.userInvolvement.amount, 0);

        return {
            group: {
                groupId: group.groupId,
                groupName: group.groupName,
                ownerEmail: group.ownerEmail,
                groupMembers: group.groupMembers || [],
                totalMembers: (group.groupMembers?.length || 0) + 1
            },
            summary: {
                youllPay: {
                    currency: 'USD', // You can make this dynamic based on group expenses
                    amount: youllPay
                },
                youllCollect: {
                    currency: 'USD',
                    amount: youllCollect
                },
                totalExpenses,
                totalUserBorrowed,
                totalUserLent
            },
            expenses: {
                list: filteredExpenses,
                byCategory: expensesByCategory,
                byDate: expensesByDate,
                count: filteredExpenses.length
            },
            filters: filters || {},
            balances: balances
        };

    } catch (error: any) {
        console.error('Error in getGroupTransactions service:', error.message);
        throw new Error(`Failed to get group transactions: ${error.message}`);
    }
};

const groupTransactionServices = {
    createGroupTransaction,
    addGroupMember,
    addGroupExpense,
    getGroupTransactions,
    getGroupStatus,
    calculateGroupBalances,
    getGroupSummary,
    settleDebt
};

export default groupTransactionServices;